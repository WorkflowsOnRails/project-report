\documentclass[document.tex]{subfiles}
\begin{document}

\chapter {Background}
\label {ch:background}

\todo {Add an overview of this section}

\sectionnote {AC}
\section {Workflow Framework Types and Notation}
\label {sec:overview-of-workflows}

\todo {Expand this section with more information on how the notations and styles differ, ex. state machine can't express responsibility and work assignment, and must compose parallel activities with communicating state machines and guards. An example of each notation would also be good to have.}

Workflows are implemented as state machines (state based) or flow charts (process based).

Workflow frameworks normally maintain the current step of the program and how the program will transition between steps. This allows what each step implements to be abstracted from how the program transitions between the many steps lowering the overall complexity of the system. This allows transitions to be modified and edited with little impact to the implementation of each individual step.

The state based model implements the workflow as a state machine. Each step is represented as a state and the following steps are represented by the state transitions. The state model acts like a state machine and is only ever in one state at any time. The state model is good at modeling workflows with well defined single states but falls apart when parallel states are required.

The process based model implements the workflow as a flow chart. This model differs from the state model in that it can easily model parallel processes. Where a state machine typically is only ever in a single state the process model can branch its flow of control to work in parallel. This is done by allowing all the transitions out of a node to be taken as long as the correct conditions are met. The process model also allows control flow to merge from two branches of control back into a single process.

BPMN \cite{bpmn} is graphical way of modeling a business process and is very similar to UML. BPMN is structured as a set of activities linked together by messages and events. Activities are the processes and can be considered the actions that need to be done. Events are actions that happen in response to something else, such as delays, and connections which describe the control flow.


\sectionnote {BM}
\section {Ruby on Rails}

Ruby on Rails \cite{rails} (often called ``Rails'') is a web application framework built on the Ruby programming language. It uses Ruby's dynamic nature and flexible syntax to provide a set of domain-specific languages (DSLs) for specific programming tasks, such as defining how objects are saved to relational databases.

Though Rails is often called a ``model-view-controller'' (MVC) web framework, its flavor of MVC differs from the conventional definition. ``Model'' refers specifically to a class of object that can be persisted to a database using ActiveRecord (Rails' object-relational mapper.) Though domain logic often is encoded in models, it may also be extracted to separate service classes which perform actions that impact multiple model instances at once.

Rails' views and controllers are somewhat more conventional. Views are templates written in a domain specific language (such as ERB \cite{erb} or Haml \cite{haml}) that generates output in a specific format, often HTML. Controllers produce HTTP responses in response to HTTP requests to specific URLs. Often, each controller class corresponds to a specific model class, and each method therein (also known as an \emph{action}) is associated with a logical operation, such as ``delete the instance of the model specified by the ID in the URL.'' Each action is usually associated with a specific view. The precise mappings from HTTP requests to controllers and actions are provided by \emph{routes}, which are specified in a another DSL.

%The concept of \emph{convention over configuration} pervades Rails %\cite{rails-article}. Convention over configuration means that common design %decisions are made by the framework itself, instead of requiring the developer %to make them themselves; for example, controller actions will by default render %a view of the same name. This policy is an ingrained part of the Rails %community; any new library (such as a new workflow platform) must follow it in %order to be accepted.

As this report includes sample code that Rails models and controllers, Figure \ref{fig:background-rails-code} provides an example of a model and controller, along with a few notes on the composition of each.

\begin{figure}[!ht]
  \begin{lstlisting}
# In app/models/order.rb:
class Order < ActiveRecord::Base
  belongs_to :buyer  # An order has a foreign key to one buyer
  has_many :items    # Zero or more items have foreign keys to an order

  # ...
end

# In app/controllers/order.rb:
class OrderController < ApplicationController
  # An action named `new':
  def new
    # ... some implementation here. ...
    #
    # By default, app/views/order/create.html.erb will be rendered when
    # the action returns.
  end

  # ...
end
  \end{lstlisting}
  \cprotect\caption{Code snippet illustrating an example Rails model and controller.}
  \label{fig:background-rails-code}
\end{figure}


\sectionnote {BM}
\section {Existing Workflow Frameworks For Rails}
\label {sec:evaluating-existing-workflow-frameworks}

Though articles discussing workflows in Ruby on Rails often list dozens of compatible ``workflow libraries'', few such libraries are actually full-fledged workflow libraries. The majority, such as StateFu, StateMachine, and Workflow, only implement extended state machines and lack features to handle access control or assignment of work to users.

There are only three relatively featureful workflow libraries for Rails: Stonepath, Ruote, and rBPM. Of the three, only Ruote and Stonepath are actively developed and compatible with modern versions of Ruby and Rails; rBPM hasn't been updated since 2006, and has never made a stable release. A brief overview of Ruote and Stonepath is provided below.

\sectionnote{BM}
\subsection {Stonepath}

Stonepath is a state-based workflow library for Ruby on Rails. Stonepath defines business processes using the concepts of work items, workbenches, and tasks \cite{stonepath}. A work item is a model that represents the focus of a workflow. It has a well-defined state and state transitions, which represent the primary activities in the workflow. Work items can be related to other models called work benches, which represent participants in a workflow such as users, groups, or software agents. Work benches may own work items that they are primarily responsible for, or may be related to work benches through tasks assigned to them. Both work items and tasks may have associated workflows.

As an example, consider an expense-claim system. The work item that is the focus of the business process is an individual expense claim, while both the employee that submitted the claim and their manager would be workbenches. A task to review the claim would like the manager to the expense claim. In this case, only the expense claim would have an associated workflow, as the task of reviewing the claim is unlikely to be so complicated that it needs its own state machine.

The state machine functionality in Stonepath is implemented by a third-party library called AASM. It provides a rich domain-specific language to specify persistent state machines, along with transition guards, entry conditions. In addition, AASM can express constraints that must only apply to the object in specific states, which is useful to ensure that data consistency. For example, if we had a project management system that tracks features, we might need to provide acceptance criteria and time estimates for a feature before it can be assigned to a developer. We could encode this in a model using AASM as in Figure
\ref{fig:stonepath-aasm}.

\todo {Provide an AASM syntax example here, not just a validation example}

\begin{figure}[!ht]
  \caption{Example of an activity precondition encoded with Stonepath}
  \label{fig:stonepath-aasm}
  \begin{lstlisting}
class Feature < ActiveRecord::Base
  # ... state definitions omitted...
  # States: new, todo, in_progress, in_testing, done, accepted, rejected
  # Acceptance criteria and hour estimated are required for features
  # that are in development, or have been developed already.

  with_options if: :in_development? do |m|
    m.validates :acceptance_criteria, presence: true
    m.validates :estimated_hours, numericality: true
  end

  def in_development?
    todo? or in_progress? or in_testing? or done? or accepted?
  end
end
  \end{lstlisting}
\end{figure}

Stonepath itself is only a thin layer on top of Rails. While it provides methods to relate workbenches to work items and tasks and automatically generate database schemas that reflect these relationships, it is lacking in many other respects. Stonepath does not provide any authentication or authorization features, relying on the developer to select appropriate libraries or implement authorization themselves. It also does not provide any tools to automatically generate user interfaces from workflows: developers need to implement appropriate views and controllers for work items and tasks by themselves. Furthermore, it lacks the ability to trigger transitions after a specified timeout. Stonepath focuses on providing a well-documented set of best practices for implementing business processes, instead of a collection of time-saving utilities.

\sectionnote {AC}
\subsection {Ruote}

In contrast to Stonepath, Ruote is a process-based workflow framework that can be integrated with any Ruby application \cite{ruote}. Though it is not specific to Ruby on Rails, it can interoperate with Rails using the Ruote-Kit library \cite{ruote-kit} integrated with Ruby on Rails, though it is not specific to Ruby on Rails. It models a workflow as a combination of processes and participants. A process represents an activity or stage of a workflow and a participant represents the agent working on that specific step of the process. Each participant can be used in multiple processes, however they are not reusable as each participant has a single \verb!on_workitem! method that is called when a process passes work to a participant. Thus participants don't model users and groups, but associations of users and groups to specific steps in a process.

\todo {We need an example here, because this is a bit hard to follow}

Each process is defined by a process definition. Process definitions describe the flow of work between the registered participants. Once the end of the process definition is reached, the process terminates and it moves on to the next process.

A work item can be seen as a collection of data passed between each process that the participants work on and modify. Ruote has complete control over the work item and can reset it and modify it at any point during the workflow.

Similar to Stonepath, Ruote does not provide any tools for authorization, authentication, or generating user interfaces automatically from processes. However, it does have support for time-limited and parallel activities out of the box. A process definition can specify how long an activity should take before it times out and invokes a \verb!on_timeout! method on the associated participants. A process definition can also specify a set of activities (or groups of activities) that run concurrently. Ruote can also synchronize separate workflows using mutexes provided by the ruote-synchronize add-on \cite{ruote-synchronize}.



\end{document}
